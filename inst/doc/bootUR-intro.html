<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Stephan Smeekes and Ines Wilms" />

<meta name="date" content="2020-06-15" />

<title>Introduction to bootUR</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to bootUR</h1>
<h4 class="author">Stephan Smeekes and Ines Wilms</h4>
<h4 class="date">June 15, 2020</h4>



<p>The R package <code>bootUR</code> implements several bootstrap tests for unit roots, both for single time series and for (potentially) large systems of time series.</p>
<div id="installation-and-loading" class="section level2">
<h2>Installation and Loading</h2>
<div id="installation" class="section level3">
<h3>Installation</h3>
<p>The development version of the <code>bootUR</code> package can be installed from GitHub using</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># install.packages(&quot;devtools&quot;)</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">devtools<span class="op">::</span><span class="kw">install_github</span>(<span class="st">&quot;smeekes/bootUR&quot;</span>)</a></code></pre></div>
<p>If you want the vignette to appear in your package, use</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># install.packages(&quot;devtools&quot;)</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">devtools<span class="op">::</span><span class="kw">install_github</span>(<span class="st">&quot;smeekes/bootUR&quot;</span>, <span class="dt">build_vignettes =</span> <span class="ot">TRUE</span>, <span class="dt">dependencies =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>instead. As building the vignette may take a bit of time (all bootstrap code below is run), package installation will be slower this way.</p>
</div>
<div id="load-package" class="section level3">
<h3>Load Package</h3>
<p>After installation, the package can be loaded in the standard way:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">library</span>(bootUR)</a></code></pre></div>
</div>
</div>
<div id="preliminary-analysis-missing-values" class="section level2">
<h2>Preliminary Analysis: Missing Values</h2>
<p><code>bootUR</code> provides a few simple tools to check if your data are suitable to be bootstrapped.</p>
<div id="inspect-data-for-missing-values" class="section level3">
<h3>Inspect Data for Missing Values</h3>
<p>The bootstrap tests in <code>bootUR</code> do not work with missing data, although multivariate time series with different start and end dates (unbalanced panels) are allowed. <code>bootUR</code> provides a simple function to check if your data contain missing values. We will illustrate this on the <code>MacroTS</code> dataset of macreconomic time series that comes with the package.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span>(<span class="st">&quot;MacroTS&quot;</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">check_missing_insample_values</span>(MacroTS)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">#&gt;  GDP_BE  GDP_DE  GDP_FR  GDP_NL  GDP_UK CONS_BE CONS_DE CONS_FR CONS_NL CONS_UK </span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">#&gt;   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE </span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">#&gt; HICP_BE HICP_DE HICP_FR HICP_NL HICP_UK   UR_BE   UR_DE   UR_FR   UR_NL   UR_UK </span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">#&gt;   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE   FALSE</span></a></code></pre></div>
</div>
<div id="checking-start-and-end-points-of-time-series" class="section level3">
<h3>Checking Start and End Points of Time Series</h3>
<p>If your time series have different starting and end points (and thus some series contain <code>NA</code>s at the beginning and/or end of your sample, the resampling-based moving block bootstrap (MBB) and sieve bootstrap (SB) cannot be used. <code>bootUR</code> lets you check the start and end points as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">sample_check &lt;-<span class="st"> </span><span class="kw">find_nonmissing_subsample</span>(MacroTS)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co"># Provides the number of the first and last non-missing observation for each series:</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">sample_check<span class="op">$</span>range </a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="co">#&gt;       GDP_BE GDP_DE GDP_FR GDP_NL GDP_UK CONS_BE CONS_DE CONS_FR CONS_NL</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">#&gt; first      1      1      1      5      1       1       1       1       5</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co">#&gt; last     100    100    100    100    100     100     100     100     100</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">#&gt;       CONS_UK HICP_BE HICP_DE HICP_FR HICP_NL HICP_UK UR_BE UR_DE UR_FR UR_NL</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="co">#&gt; first       1       9       9       9       9       9     1     1     1     1</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="co">#&gt; last      100     100     100     100     100     100   100   100   100   100</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="co">#&gt;       UR_UK</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="co">#&gt; first     1</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="co">#&gt; last    100</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="co"># Gives TRUE if the time series all start and end at the same observation:</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">sample_check<span class="op">$</span>all_equal</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="co">#&gt; [1] FALSE</span></a></code></pre></div>
</div>
</div>
<div id="univariate-bootstrap-unit-root-tests" class="section level2">
<h2>Univariate Bootstrap Unit Root Tests</h2>
<div id="augmented-dickey-fuller-test" class="section level3">
<h3>Augmented Dickey-Fuller Test</h3>
<p>To perform a standard augmented Dickey-Fuller (ADF) bootstrap unit root test on a single time series, use the <code>boot_df()</code> function. The function allows to set many options, including the bootstrap method used (option <code>boot</code>), the deterministic components included (option <code>dc</code>) and the type of detrending used. Setting <code>boot = &quot;MBB&quot;</code> gives the test proposed by Paparoditis and Politis (2003). While <code>dc = &quot;OLS&quot;</code> gives the standard ADF test, <code>dc = &quot;QD&quot;</code> provides the powerful DF-GLS test of Elliott, Rothenberg and Stock (1996). Here we use the terminology Quasi-Differencing (QD) rather than GLS as this conveys the meaning less ambiguously and is the same terminology used by Smeekes and Taylor (2012) and Smeekes (2013).</p>
<p><strong>Lag selection</strong></p>
<p>Lag length selection is done automatically in the ADF regression; the default is by the modified Akaike information criterion (MAIC) proposed by Ng and Perron (2001) with the correction of Perron and Qu (2008). Other options include the regular Akaike information criterion (AIC), as well as the Bayesian information criterion and its modified variant. In addition, the rescaling suggested by Cavaliere et al. (2015) is implemented to improve the power of the test under heteroskedasticity; this can be turned off by setting <code>ic_scale = FALSE</code>. To overwrite data-driven lag length selection with a pre-specified lag length, simply set both the minimum <code>p_min</code> and maximum lag length <code>p_max</code> for the selection algorithm equal to the desired lag length.</p>
<p><strong>Implementation</strong></p>
<p>We illustrate the bootstrap ADF test here on Dutch GDP, with the sieve bootstrap (<code>boot = SB</code>) as in the specification used by Palm, Smeekes and Urbain (2008) and Smeekes (2013). We set only 399 bootstrap replications (<code>B = 399</code>) to prevent the code from running too long. We add an intercept and a trend (<code>dc = 2</code>), and compare OLS with QD (GLS) detrending. The option <code>verbose = TRUE</code> prints easy to read output on the console. To see live progress updates on the bootstrap, set <code>show_progress = TRUE</code>. This is particularly useful for large <code>B</code>, so we leave it out here. As random number generation is required to draw bootstrap samples, we first set the seed of the random number generator to obtain replicable results.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">155776</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">GDP_NL &lt;-<span class="st"> </span>MacroTS[, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">adf_out &lt;-<span class="st"> </span><span class="kw">boot_df</span>(GDP_NL, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">boot =</span> <span class="st">&quot;SB&quot;</span>, <span class="dt">dc =</span> <span class="dv">2</span>, <span class="dt">detr =</span> <span class="kw">c</span>(<span class="st">&quot;OLS&quot;</span>, <span class="st">&quot;QD&quot;</span>), <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">#&gt; Bootstrap DF Test with SB bootstrap method.</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">#&gt; ----------------------------------------</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">#&gt; Type of unit root test performed: detr = OLS, dc = intercept and trend</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">#&gt; test statistic        p-value </span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="co">#&gt;     -2.5152854      0.1353383 </span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="co">#&gt; ----------------------------------------</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="co">#&gt; Type of unit root test performed: detr = QD, dc = intercept and trend</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="co">#&gt; test statistic        p-value </span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="co">#&gt;     -1.5965001      0.4185464</span></a></code></pre></div>
</div>
<div id="union-of-rejections-test" class="section level3">
<h3>Union of Rejections Test</h3>
<p>Use <code>boot_union()</code> for a test based on the union of rejections of 4 tests with different number of deterministic components and different type of detrending (Smeekes and Taylor, 2012). The advantage of the union test is that you don’t have to specify these (rather influential) specification tests. This makes the union test a safe option for quick or automatic unit root testing where careful manual specification setup is not viable. Here we illustrate it with the sieve wild bootstrap as proposed by Smeekes and Taylor (2012).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">union_out &lt;-<span class="st"> </span><span class="kw">boot_union</span>(GDP_NL, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">boot =</span> <span class="st">&quot;SWB&quot;</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">#&gt; Bootstrap Test with SWB bootstrap method.</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">#&gt; Bootstrap Union Test:</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co">#&gt; The null hypothesis of a unit root is not rejected at a significance</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">#&gt;                     level of 0.05.</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">#&gt; test statistic        p-value </span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="co">#&gt;     -0.6722611      0.6090226</span></a></code></pre></div>
</div>
</div>
<div id="panel-unit-root-test" class="section level2">
<h2>Panel Unit Root Test</h2>
<p>The function <code>panel_test</code> performs a test on a multivariate (panel) time series by testing the null hypothesis that all series have a unit root. A rejection is typically interpreted as evidence that a ‘significant proportion’ of the series is stationary, although how large that proportion is - or which series are stationary - is not given by the test. The test is based on averaging the individual test statistics, also called the Group-Mean (GM) test in Palm, Smeekes and Urbain (2011).</p>
<p>Palm, Smeekes and Urbain (2011) introduced this test with the moving block bootstrap (<code>boot = &quot;MBB&quot;</code>), which is the standard option. However, this resampling-based method cannot handle unbalancedness, and will therefore give an error when applied to <code>MacroTS</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">panel_out &lt;-<span class="st"> </span><span class="kw">paneltest</span>(MacroTS, <span class="dt">boot =</span> <span class="st">&quot;MBB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#&gt; Error in check_inputs(y = y, BSQT_test = BSQT_test, iADF_test = iADF_test, : Resampling-based bootstraps MBB and SB cannot handle unbalanced series.</span></a></code></pre></div>
<p>Therefore, you should switch to one of the wild bootstrap methods. Here we illustrate it with the dependent wild bootstrap (DWB) of Shao (2010) and Rho and Shao (2019).</p>
<p>By default the union test is used for each series (<code>union = TRUE</code>), if this is set to <code>FALSE</code> the deterministic components and detrending methods can be specified as in the univariate Dickey-Fuller test.</p>
<p>Although the sieve bootstrap method <code>&quot;SB&quot;</code> and <code>&quot;SWB&quot;</code> can be used (historically they have been popular among practitioners), Smeekes and Urbain (2014b) show that these are not suited to capture general forms of dependence across units. The code will give a warning to recommend using a different bootstrap method.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">panel_out &lt;-<span class="st"> </span><span class="kw">paneltest</span>(MacroTS, <span class="dt">boot =</span> <span class="st">&quot;DWB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">#&gt; Panel Bootstrap Group-Mean Union Test</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">#&gt; The null hypothesis that all series have a unit root, is</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">#&gt;                   rejected at a significance level of 0.05.</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co">#&gt;      test statistic    p-value</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">#&gt; [1,]     -0.8474483 0.03759398</span></a></code></pre></div>
</div>
<div id="tests-for-multiple-time-series" class="section level2">
<h2>Tests for Multiple Time Series</h2>
<div id="individual-adf-tests" class="section level3">
<h3>Individual ADF Tests</h3>
<p>To perform individual ADF tests on multiple time series simultaneously, the function <code>iADFtest()</code> can be used. As the bootstrap is performed for all series simultaneously, resampling-based bootstrap methods <code>&quot;MBB&quot;</code> and <code>&quot;SB&quot;</code> cannot be used directly in case of unbalanced panels. If they are used anyway, the function will revert to splitting the bootstrap up and performing it individually per time series. In this case a warning is given to alert the user. The other options are the same as for <code>paneltest</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">iADF_out &lt;-<span class="st"> </span><span class="kw">iADFtest</span>(MacroTS[, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>], <span class="dt">boot =</span> <span class="st">&quot;MBB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>, <span class="dt">union =</span> <span class="ot">FALSE</span>, </a>
<a class="sourceLine" id="cb10-2" data-line-number="2">                     <span class="dt">dc =</span> <span class="dv">2</span>, <span class="dt">detr =</span> <span class="st">&quot;OLS&quot;</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">#&gt; Warning in check_inputs(y = y, BSQT_test = BSQT_test, iADF_test = iADF_test, :</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">#&gt; Missing values cause resampling bootstrap to be executed for each time series</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">#&gt; individually.</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co">#&gt; ----------------------------------------</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt; Type of unit root test performed: detr = OLS, dc = intercept and trend</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">#&gt; There are 0 stationary time series</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">#&gt;        test statistic    p-value</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">#&gt; GDP_BE      -2.792169 0.24060150</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">#&gt; GDP_DE      -2.774320 0.07769424</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co">#&gt; GDP_FR      -2.048760 0.52882206</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="co">#&gt; GDP_NL      -2.515285 0.19047619</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">#&gt; GDP_UK      -2.449065 0.30325815</span></a></code></pre></div>
<p>Note that <code>iADFtest</code> (intentionally) does not provide a correction for multiple testing; of course, if we perform each test with a significance level of 5%, the probability of making a mistake in all these tests becomes (much, if <code>N</code> is large) more than 5%. To explicitly account for multiple testing, use the functions <code>BSQTtest()</code> or <code>bFDRtest()</code>.</p>
</div>
<div id="bootstrap-sequential-tests" class="section level3">
<h3>Bootstrap Sequential Tests</h3>
<p>The function <code>BSQTtest()</code> performs the Bootstrap Sequential Quantile Test (BSQT) proposed by Smeekes (2015). Here we split the series in groups which are consecutively tested for unit roots, starting with the group most likely to be stationary (having the smallest ADF statistics). If the unit root hypothesis cannot be rejected for the first group, the algorithm stops; if there is a rejection, the second group is tested, and so on.</p>
<p>Most options are the same as for <code>paneltest</code>. The most important new parameter to set here is the group sizes. These can either be set in units, or in fractions of the total number of series (i.e. quantiles, hence the name) via the parameter <code>q</code>. If we have <code>N</code> time series, setting <code>q = 0:N</code> means each unit should be tested sequentially. To split the series in four equally sized groups (regardless of many series there are), use <code>q = 0:4 / 4</code>. By convention and in accordance with notation in Smeekes (2015), the first entry of the vector should be equal to zero, while the second entry indicates the end of the first group, and so on. However, if the initial zero is accidentally omitted, it is automatically added by the function. Similarly, if the final value is not equal to <code>1</code> (in case of quantiles) or <code>N</code> to end the last group, this is added by the function.</p>
<p>Testing individual series consecutively is easiest for interpretation, but is only meaningful if <code>N</code> is small. In this case the method is equivalent to the bootstrap StepM method of Romano and Wolf (2005), which controls the familywise error rate, that is the probability of making at least one false rejection. This can get very conservative if <code>N</code> is large, and you would typically end up not rejecting any null hypothesis. The method is illustrated with the autoregressive wild bootstrap of Smeekes and Urbain (2014a) and Friedrich, Smeekes and Urbain (2020).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">N &lt;-<span class="st"> </span><span class="kw">ncol</span>(MacroTS)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co"># Test each unit sequentially</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">BSQT_out1 &lt;-<span class="st"> </span><span class="kw">BSQTtest</span>(MacroTS, <span class="dt">q =</span> <span class="dv">0</span><span class="op">:</span>N, <span class="dt">boot =</span> <span class="st">&quot;AWB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="co">#&gt; There is 1 stationary time series, namely: HICP_DE.</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="co">#&gt; Details of the BSQT ssquential tests:</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="co">#&gt;        Unit H0 Unit H1 Test statistic    p-value</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="co">#&gt; Step 1       0       1      -1.645621 0.02005013</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="co">#&gt; Step 2       1       2      -1.361195 0.17794486</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="co"># Split in four equally sized groups (motivated by the 4 series per country)</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">BSQT_out2 &lt;-<span class="st"> </span><span class="kw">BSQTtest</span>(MacroTS, <span class="dt">q =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">4</span> <span class="op">/</span><span class="st"> </span><span class="dv">4</span>, <span class="dt">boot =</span> <span class="st">&quot;AWB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="co">#&gt; Warning in min(p_vec): no non-missing arguments to min; returning Inf</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="co">#&gt; Warning in check_inputs(y = y, BSQT_test = BSQT_test, iADF_test = iADF_test, :</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="co">#&gt; Input to argument q transformed to fit sequential test: q = c(0, 0, 0.25, 0.5,</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"><span class="co">#&gt; 0.75, 1)</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="co">#&gt; There are 5 stationary time series, namely: GDP_DE HICP_BE HICP_DE HICP_FR HICP_NL.</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="co">#&gt; Details of the BSQT ssquential tests:</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17"><span class="co">#&gt;        Unit H0 Unit H1 Test statistic    p-value</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18"><span class="co">#&gt; Step 1       0       5      -1.073928 0.01503759</span></a>
<a class="sourceLine" id="cb11-19" data-line-number="19"><span class="co">#&gt; Step 2       5      10      -0.888729 0.34586466</span></a></code></pre></div>
</div>
<div id="bootstrap-fdr-controlling-tests" class="section level3">
<h3>Bootstrap FDR Controlling Tests</h3>
<p>The function <code>bFDRtest()</code> controls for multiple testing by controlling the false discovery rate (FDR), which is defined as the expected proportion of false rejections relative to the total number of rejections. This scales with the total number of tests, making it more suitable for large <code>N</code> than the familywise error rate.</p>
<p>The bootstrap method for controlling FDR was introduced by Romano, Shaikh and Wolf (2008), who showed that, unlike the classical way to control FDR, the bootstrap is appropriate under general forms of dependence between series. Moon and Perron (2012) applied this method to unit root testing; it is essentially their method which is implemented in <code>bFDRtest()</code> though again with the option to change the bootstrap used (their suggestion was MBB). The arguments to be set are the same as for the other multivariate unit root tests, though the meaning of <code>level</code> changes from regular significance level to FDR level. As BSQT, the method only report those tests until no rejection occurs.</p>
<p>We illustrate it here with the final available bootstrap method, the block wild bootstrap of Shao (2011) and Smeekes and Urbain (2014a).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">N &lt;-<span class="st"> </span><span class="kw">ncol</span>(MacroTS)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">bFDR_out &lt;-<span class="st"> </span><span class="kw">bFDRtest</span>(MacroTS[, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>], <span class="dt">level =</span> <span class="fl">0.1</span>, <span class="dt">boot =</span> <span class="st">&quot;BWB&quot;</span>, <span class="dt">B =</span> <span class="dv">399</span>, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="co">#&gt; There are 0 stationary time series</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">#&gt; Details of the FDR sequential tests:</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">#&gt;        test statistic critical value</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">#&gt; GDP_DE      -1.115581      -1.612193</span></a></code></pre></div>
</div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<ul>
<li>Cavaliere, G., Phillips, P.C.B., Smeekes, S., and Taylor, A.M.R. (2015). Lag length selection for unit root tests in the presence of nonstationary volatility. <em>Econometric Reviews</em>, 34(4), 512-536.</li>
<li>Elliott, G., Rothenberg, T.J., and Stock, J.H. (1996). Efficient tests for an autoregressive unit root. <em>Econometrica</em>, 64(4), 813-836.</li>
<li>Friedrich, M., Smeekes, S. and Urbain, J.-P. (2020). Autoregressive wild bootstrap inference for nonparametric trends. <em>Journal of Econometrics</em>, 214(1), 81-109.</li>
<li>Moon, H.R. and Perron, B. (2012). Beyond panel unit root tests: Using multiple testing to determine the non stationarity properties of individual series in a panel. <em>Journal of Econometrics</em>, 169(1), 29-33.</li>
<li>Ng, S. and Perron, P. (2001). Lag Length Selection and the Construction of Unit Root Tests with Good Size and Power. <em>Econometrica</em>, 69(6), 1519-1554,</li>
<li>Palm, F.C., Smeekes, S. and Urbain, J.-P. (2008). Bootstrap unit root tests: Comparison and extensions. <em>Journal of Time Series Analysis</em>, 29(1), 371-401.</li>
<li>Palm, F. C., Smeekes, S., and Urbain, J.-.P. (2011). Cross-sectional dependence robust block bootstrap panel unit root tests. <em>Journal of Econometrics</em>, 163(1), 85-104.</li>
<li>Paparoditis, E. and Politis, D.N. (2003). Residual‐based block bootstrap for unit root testing. <em>Econometrica</em>, 71(3), 813-855.</li>
<li>Perron, P. and Qu, Z. (2008). A simple modification to improve the finite sample properties of Ng and Perron’s unit root tests. <em>Economic Letters</em>, 94(1), 12-19.</li>
<li>Rho, Y. and Shao, X. (2019). Bootstrap-assisted unit root testing with piecewise locally stationary errors. <em>Econometric Theory</em>, 35(1), 142-166.</li>
<li>Romano, J.P., Shaikh, A.M., and Wolf, M. (2008). Control of the false discovery rate under dependence using the bootstrap and subsampling. <em>Test</em>, 17(3), 417.</li>
<li>Romano, J. P. and Wolf, M. (2005). Stepwise multiple testing as formalized data snooping. <em>Econometrica</em>, 73(4), 1237-1282.</li>
<li>Shao, X. (2010). The dependent wild bootstrap. <em>Journal of the American Statistical Association</em>, 105(489), 218-235.</li>
<li>Shao, X. (2011). A bootstrap-assisted spectral test of white noise under unknown dependence. <em>Journal of Econometrics</em>, 162, 213-224.</li>
<li>Smeekes (2013). Detrending bootstrap unit root tests. <em>Econometric Reviews</em>, 32(8), 869-891.</li>
<li>Smeekes, S. (2015). Bootstrap sequential tests to determine the order of integration of individual units in a time series panel. <em>Journal of Time Series Analysis</em>, 36(3), 398-415.</li>
<li>Smeekes, S. and Taylor, A.M.R. (2012). Bootstrap union tests for unit roots in the presence of nonstationary volatility. <em>Econometric Theory</em>, 28(2), 422-456.</li>
<li>Smeekes, S. and Urbain, J.-P. (2014a). A multivariate invariance principle for modified wild bootstrap methods with an application to unit root testing. GSBE Research Memorandum No. RM/14/008, Maastricht University.</li>
<li>Smeekes, S. and Urbain, J.-P. (2014b). On the applicability of the sieve bootstrap in time series panels. <em>Oxford Bulletin of Economics and Statistics</em>, 76(1), 139-151.</li>
</ul>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
